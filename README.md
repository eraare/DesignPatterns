# 设计模式 DesignPatterns
> Give 23 examples for the GoF Design Patterns.

![设计模式](http://upload-images.jianshu.io/upload_images/3587463-657e122b18b468c5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

> 模式：所谓模式就是指在某种情境下针对某问题的某种解决方案。
>
> 愿力与你同在：目标与约束
>
> 编程真理：CHANGE
>
> OO基础：抽象 封装 继承 多态

## 面向对象（OO, Object Oriented）
> 面向对象的程序设计方法将数据及对数据的操作封装在一起，形成一个相互依赖不可分离的整体即
>
> 为对象。对同类型的对象抽象出其共性形成类。

## 统一建模语言（UML, Unified Modeling Language）

> 6大类：组件图 静态图 交互图 行为图 用例图 物理图 
>
> 9种图：构件图 类图/对象图 序列图/协作图 活动图/状态机图 用例图 部署图
>
> 6关系：泛化=实现>组合>聚合>关联>依赖

## 设计原则（SOLLID, 6）

> 1 封装变化。将可能发生变化的代码提取出来，封装成类。
>
> 2 针对接口编程，而非针对实现编程。
>
> 3 多用组合，少用继承。
>
> 4 为交互对象之间的松耦合设计而努力。
>
> 5 开放关闭原则。对扩展开放，对修改关闭。O
>
> 6 依赖倒置原则。依赖抽象，而非依赖具体类。D
>
> 7 最少知识原则。只和你的密友谈话。L
>
> 8 好莱坞原则。Don't call me, I'll call you.
>
> 9 单一职责原则。一个类应该仅有一个引起它变化的原因。S
>
> 10 里氏替换原则。父类出现的地方，子类也可出现。L
>
> 11 接口隔离原则。最小接口。I

## 设计模式（GOF, Gang Of Four, 23）

> *创建型：单例模式 工厂方法模式 抽象工厂模式 建造者模式 原型模式 5*
>
> *行为型：观察者模式 策略模式 命令模式 状态模式 解释器模式 迭代器模式 访问者模式 中介者模式 责任链模式 备忘录模式 模板方法模式 11*
>
> *结构型：适配器模式 装饰者模式 代理模式 外观模式 组合模式 桥接模式 享元模式 7*

> - 单例模式：确保程序中仅有类的一个实例，并且自行实例化为全局提供。
> - 工厂方法模式：对象的工厂，将类的实例化延迟到子类进行。
> - 抽向工厂模式：工厂的工厂，为一系列的产品提供一个统一的创建工厂。
> - 建造者模式：将一个复杂对象构建过程与其表示分离，使得同一构建过程可以创建不同的表示。
> - 原型模式：定义一个对象的原型，通过克隆来创建对象的副本。
> - 观察者模式：表示一种一对多的对应关系，多个对象同时监听一个对象，当被监听对象的状态发生改变时，其可以动态的改变其本身。
> - 策略模式：定义一系列的算法，并将这些算法封装起来，使它们可以相互替换。
> - 命令模式：将请求封装起来，以便使用不同的请求、日志和队列来参数化其他对象，命令模式支持撤销操作。
> - 状态模式：允许对象在其状态发生改变时可以改变其行为，从外表来看，对象似乎改变了其类。
> - 解释器模式：给定一种语言，定义其文法的一种表示，同时定义一个解释器，解释器使用此文法解释语言中的句子。
> - 迭代器模式：提供一种方法可以顺序的访问一个聚合对象的所有元素，同时又不爆露类的内部结构。
> - 访问者模式：表示一个作用于某对象结构中各元素的操作，它使你在不改变各元素类的前提下定义作用于这些元素的新操作。
> - 中介者模式：用一个中介者对象来封装一系列的对象交互，中介者使得各对象之间不需要显示的相互引用，从而使其松散耦合，同时可以独立的改变他们之间的交互。
> - 责任链模式：每个对象都保持下一个对象的引用而形成链，请求在此链上传递，直到某个对象处理了该请求。对于客户端而言，并不知道哪个对象处理了该请求，可以重新组合分配任务职责。
> - 备忘录模式：在不影响封装的前提下，捕获一个对象的状态，并在该对象之外保存此状态，使得之后可以恢复对象到此状态。
> - 模板方法模式：定义一个算法的骨架，将某些步骤延迟到子类进行。
> - 适配器模式：将一个接口转换成客户端所期望的接口，解决由于接口不匹配所导致的类的兼容性问题。
> - 装饰者模式：动态的为对象添加功能。
> - 代理模式：控制对象的访问。
> - 外观模式：为子系统中的一系列接口提供一个统一的界面，定义一个高层接口，这个接口使得子系统的操作更加方便。
> - 组合模式：将对象组合成树形结构来表示整体部分的层次关系，使得客户端对单个对象和组合对象具有一致的操作。
> - 桥接模式：将抽象部分与实现部分分离，使抽象和实现均可独立的发生变化。
> - 享元模式：通过共享来减少内存中对象的个数。

> **高内举，低耦合**
>
> **抽象**
